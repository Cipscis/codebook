<!DOCTYPE html>
<html>
<head>
	<title>Codebook</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<link rel="stylesheet" href="/codebook/assets/css/main.css" />
	<script type="module" src="/codebook/assets/js/dist/bundle.js"></script>
</head>
<body>
	<main class="layout">
		<section>
			<div class="content">
				<h1>Codebook</h1>

				<p>Codebook allows you to execute code that is also shown to the user embedded in an HTML page.</p>
			</div>
		</section>

		<section>
			<div class="content">
				<h2>Install</h2>

				<p>Codebook can be installed as an npm package from GitHub.</p>

				<code class="code--block">npm install github:cipscis/codebook#semver:^1.0.0</code>

				<p>Then, if you are using a package builder like Webpack to allow you to use JavaScript from your <code>node_modules</code> folder, you can import codebook into your module:</p>

				<code class="code--block js-codebook__inert">
					import codebook from 'codebook';
				</code>
			</div>
		</section>

		<section class="js-codebook__set">
			<div class="content">
				<h2>Usage</h2>

				<p>Codebook needs two parts to work: the code on the page that should be run, and the JavaScript to run it.</p>

				<p>The code on the page comes in <strong>blocks</strong>, which should have a class of <code>js-codebook__code</code>. These blocks can belong to sets, which are run independently.</p>

				<p>On this page, code blocks are marked by a üìñ character.</p>

				<h3>Sets</h3>

				<p>By default, a block belongs to a special set called the "default" set. However, it can be added to a specific set by specifying a set name via a <code>data-codebook-set</code> attribute in one of two places:</p>

				<ul>
					<li>On the block itself</li>
					<li>On an ancestor of the code block, which also has the class <code>js-codebook__set</code></li>
				</ul>

				<p>If a set is specified in both of those places, the set specified on the block itself will take precedence. Code blocks can only belong to a single set.</p>

				<p>Code blocks in a set have two helper methods exposed that allow them to print output to the page:</p>

				<code>log(...output)</code>

				<p>If a code block has a log output element specified via a <code>data-codebook-log</code> attribute with a value matching the <code>id</code> attribute of the log output element, the <code>log</code> method will print output to that element when called.</p>

				<p>On this page, codebook logs are marked by a üìù character.</p>

				<p>It will attempt to convert <code>Date</code> and <code>Object</code> to strings intelligently, otherwise it will attempt to coerce each value to a string.</p>

				<code>html(string htmlOutput)</code>

				<p>If a code block has an HTML output element specified via a <code>data-codebook-html</code> attribute with a value matching the <code>id</code> attribute of the log output element, the <code>html</code> method will overwrite that element's inner HTML with whatever custom HTML is passed in as the <code>htmlOutput</code> argument.</p>

				<h4>Global set</h4>

				<p>There is a special set with the name <code>global</code>, which can be used to execute code in the global scope. This allows codebook blocks to create variables that can be later used across multiple sets. However, blocks in the global set do not have <code>log</code> or <code>html</code> functions, and do not have access to custom arguments.</p>

				<h3>Asynchronous code</h3>

				<p>Particularly because the <code>log</code> and <code>html</code> methods take on different values at different times, any asynchronous functions called within a codebook block should be called using the <code>await</code> keyword, to ensure that all code within the block finished running before the next block runs.</p>

				<p>Codebook wraps each block in an <code>async</code> function, so <code>await</code> can be used. As a result, the methods used to run code sets each return a <code>Promise</code>, which resolves when all specified sets have finished running.</p>
			</div>

			<section>
				<div class="content">
					<h2>Methods</h2>
				</div>

				<section>
					<div class="content">
						<h3>run</h3>

						<code>Promise codebook.run(Object? args);</code>

						<p>The <code>run</code> method runs all sets of code on a page. The "global" set of code, if it exists, is always run first. Then any remaining sets are run in the order in which they appear on the page.</p>

						<h4>Index</h4>

						<p>Code within a set will run in the order in which it appears in the markup, unless it has a <code>data-codebook-index</code> attribute. This attribute should be an integer, and code with a lower number here will run first. Code blocks with an index will always run before code blocks without an index, and if code blocks have the same index then they will run in the order in which they appear in the markup.</p>

						<h4>Passing arguments</h4>

						<p><code>run</code> takes a single optional argument, which is an <code>Object</code> containing named arguments to be passed to your code. This can be used to expose objects that don't exist on the global scope, such as packages that have been imported into a module.</p>

						<code class="code--block js-codebook__inert">
							codebook.run({
								testArg: 'test',
							});
						</code>
					</div>
				</section>

				<section>
					<div class="content">
						<h3>runSet</h3>

						<code>Promise codebook.runSet(string | null setName, Object? args);</code>

						<p>The <code>runSet</code> method allows you to run a specific set of code, instead of all of them. The <code>setName</code> argument should be either a string matching the name of the set, or <code>null</code> to run the "null" set.</p>

						<code class="code--block js-codebook__inert">
							codebook.runSet('test', { testArg: 'test2' });
						</code>
					</div>
				</section>

				<section>
					<div class="content">
						<h3>tidy</h3>

						<code>void codebook.tidy();</code>

						<p>The <code>tidy</code> method looks for all codebook code blocks and analyses their shared indentation based on how much the first line of code is indented. Then it strips all lines in that block by the same amount, so code appearing on the page using CSS rules like <code>white-space: pre;</code> won't appear hugely indented, but the source HTML code can still be tidily indented.</p>

						<p>As well as code blocks, the <code>tidy</code> method will also tidy "inert" blocks by looking for elements with a class of <code>js-codebook__inert</code>. These blocks are otherwise ignored by codebook, and it won't try to run any code they contain.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h2>Examples</h2>
				</div>

				<section data-codebook-set="global">
					<div class="content">
						<h3>Global set</h3>

						<p>This code belongs to the global set, and defines a function to be used later within other sets.</p>
					</div>

					<script type="text/plain" class="codebook__code js-codebook__code">
						const globalDouble = (a) => a * 2;
					</script>
				</section>

				<section>
					<div class="content">
						<h3>Default set</h3>

						<p>This code block belongs to the default set, and has <code>log</code> and <code>html</code> output elements defined.</p>
					</div>

					<script type="text/plain" class="codebook__code js-codebook__code" data-codebook-log="log-default-set-example" data-codebook-html="html-default-set-example">
						// Custom argument
						log(`Custom argument: ${testArg}`);

						// Global function
						log(`Global function: ${globalDouble(3)}`);

						// Await
						let json = await fetch('https://jsonplaceholder.typicode.com/todos/1').then(response => response.json());
						log('Await:', json);

						// Custom markup
						let markup = `<button type="button">Arbitrary markup</button>`;
						html(markup);
					</script>

					<samp class="codebook__log" id="log-default-set-example"></samp>

					<div id="html-default-set-example"></div>
				</section>
			</section>
		</section>
	</main>
</body>

</html>
